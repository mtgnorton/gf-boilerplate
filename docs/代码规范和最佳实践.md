## 概述
- 代码规范主要的约束是通过golangci-lint静态检查来实现,所以必须详细阅读[.golangci.yml](../.golangci.yml)文件. 
- 参考规范 
    - https://go.dev/doc/effective_go 
    - **必读**: https://github.com/zc2638/go-standard/blob/main/docs/style.md
- 下面的规范将只对一些重点的规范进行说明
## 命名
- 使用驼峰命名法
- 所有命名必须清晰,有意义,避免使用无意义的命名,除包名,生命周期短的局部变量除外尽量使用长命名,避免使用缩写,可借助大模型生成
- 包名
    - 全部小写。没有大写或下划线。
    - 不用复数。例如`net/url`，而不是`net/urls`。
- 文件名
    - 可包含下划线
- 错误
    - 错误变量以Err开头

## 注释
- **所有导出的结构体,方法,函数,除了id,name这种一眼就能看懂的,必须为每个字段或参数添加注释,对于一些复杂的核心逻辑,必须提供注释说明,并且注释也必须跟随代码更新**


## 文件结构
对于非gf框架mvc的文件,即需要自定义的文件,按照如下顺序组织
```go
// 1. 包声明
package mypkg

// 2. 导入语句
import (
    "fmt"
)

// 3. 常量声明
const (
    DefaultName = "unknown"
    MaxAge      = 120
)

// 4. 全局变量（依赖构造函数）
var (
    DefaultPerson = NewPerson(DefaultName, 0)
)

// 5. 类型定义
type Person struct {
    name string
    age  int
}

// 6. 构造函数
func NewPerson(name string, age int) *Person {
    return &Person{
        name: name,
        age:  age,
    }
}

// 7. 导出方法
func (p *Person) SetName(name string) {
    p.name = name
}
// 8. 非导出方法
func (p *Person) validateAge() bool {
    return p.age >= 0 && p.age <= MaxAge
}
// 9. 其他函数
func IsElder(p *Person) bool {
    return p.age >= 60
}
```
## 最佳实践
### 值接收者和指针接收者
 - 参考: https://blog.mtgnorton.site/blog/2024-04-11-golang%20%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85
### 零值 Mutex 是有效的
```go
// bad 
mu := new(sync.Mutex)

// good
var mu sync.Mutex

// 结构体
// 非导出类型内嵌
type smap struct {
sync.Mutex // only for unexported types（仅适用于非导出类型）
data map[string]string
}
// 导出类型
type Smap struct {
mu sync.Mutex // only for unexported types（仅适用于非导出类型）
data map[string]string
}
```

### 在边界处拷贝 Slices 和 Maps
- slices 和 maps 包含了指向底层数据的指针，slice和map作为参数或者返回值时,需要明确是否是特意传递原变量,否则可能发生非预期的修改,此时应该传递拷贝

### nil是一个有效的slice
- 不应明确返回长度为零的切片。应该返回nil 来代替。
    ```go
    // bad
    if x == "" {
    return []int{}
    }

    // good
    if x == "" {
    return nil
    }
    ```
- 要检查切片是否为空，请始终使用len(s) == 0。而非 nil。
    ```go
    // bad
    func isEmpty(s []string) bool {
    return s == nil
    }

    // good
    func isEmpty(s []string) bool {
    return len(s) == 0
    }
    ```
- 零值切片（用var声明的切片）可立即使用，无需调用make()创建。
    ```go
    // bad
    nums := []int{}
    if add1 {
    nums = append(nums, 1)
    }

    // good
    var nums []int
    if add1 {
    nums = append(nums, 1)
    }
    ```
### Channel 的 size 要么是 1,要么是无缓冲的

### 所有断言必须使用"comma,ok"的形式
```go
// bad
t := i.(int)

// good
t, ok := i.(int)
```
### 业务代码禁用init()函数,必须进行显示调用


## gf 规范
### 优先使用框架自带的参数校验,https://goframe.org/docs/core/gvalid-rules
### api层中定义的请求响应参数,供controller,service,model 使用,但是api层不能反向调用controller,service,model定义的结构
### 内部模块之间的调用参数和返回通过在model层下定义结构体,比如是 controller->service 或者 service->service 之间的调用,这部分输入输出模型名称通常以 XxxInput 和 XxxOutput 格式命名。

