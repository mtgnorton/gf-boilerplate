# 本文件采用 MIT 许可证 https://opensource.org/license/mit
# 版权所有 (c) 2021-2025 Marat Reymers

## GolangCI-Lint 黄金配置 v2.0.2
#
# 这是基于作者经验和观点整理的最佳实践配置
# 配置规则较为严格但不过分苛刻
# 建议根据实际项目需求进行调整
# 如果本配置对您有帮助，请保留本文件链接作为参考

# 基于 https://gist.github.com/maratori/47a4d00457a92aa426dbd48a18776322

version: "2"

# issues 配置用于控制问题报告的行为
issues:
  # 设置相同问题最多报告的次数
  # 例如：如果有100个函数都犯了同样的错误，最多只报告50次
  # 设置为0则不限制报告次数
  max-same-issues: 50

# formatters 配置代码格式化工具
formatters:
  enable:
    # goimports: 自动处理 Go 代码的导入语句，包括:
    # 1. 删除未使用的导入
    # 2. 添加缺少的导入
    # 3. 对导入进行分组和排序
    # 例如会将:
    # import (
    #   "fmt"
    #   "github.com/pkg/errors"
    #   "os"
    # )
    # 格式化为:
    # import (
    #   "fmt"
    #   "os"
    #
    #   "github.com/pkg/errors"
    # )
    - goimports

    # golines: 自动处理长代码行，使其更易读
    # 例如会将:
    # veryLongFunctionCall(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)
    # 格式化为:
    # veryLongFunctionCall(
    #   param1, param2, param3,
    #   param4, param5, param6,
    #   param7, param8, param9, param10,
    # )
    - golines

  settings:
    goimports:
      # 指定哪些包应该被视为本地包
      # 这些包会在导入语句中被分到单独的组
      local-prefixes:
        - gf-boilerplate

    golines:
      # 设置单行代码的最大长度
      # 超过这个长度的行会被自动折行
      max-len: 120

# linters 配置各种代码检查工具
linters:
  enable:
    # === 基础代码质量检查 ===
    
    #检查在可变参数函数 `func(...any)` 中将 `[]any` 作为 `any` 传递的情况。
    - asasalint

    # asciicheck: 检查代码中的非ASCII字符
    # 例如发现变量名中的中文字符: var 变量 = 1
    - asciicheck

    # bodyclose: 检查HTTP响应体是否正确关闭
    # 例如:
    # resp, err := http.Get(url)
    # if err != nil {
    #   return err
    # }
    # // 错误: 未调用 resp.Body.Close()
    - bodyclose

    # cyclop: 检查函数的圈复杂度(代码分支的数量)
    # 例如: 过多的if-else分支会增加圈复杂度
    - cyclop

    # dupl: 检测重复的代码片段
    # 例如: 多个函数中存在完全相同的代码块
    - dupl

    # errcheck: 检查未处理的错误
    # 例如:
    # file.Write(data) // 错误: 未检查写入错误
    - errcheck

    # === 代码规范检查 ===

    # goconst: 查找可以转换为常量的重复字符串
    # 例如:
    # if status == "active" {}
    # 建议: const StatusActive = "active"
    - goconst

    # gocritic 是 Go 语言的一个 静态代码分析工具，专注于检测代码中的 潜在问题 和 可改进点。
    # 1. 代码质量检查
    # 冗余代码
    # 检测不必要的类型转换、冗余的 return 语句等。
    # 示例规则：
    # unslice：冗余的切片操作（如 s[a:len(s)] → s[a:]）
    # yodaStyleExpr：避免反直觉的表达式顺序（如 if nil == err → if err == nil）

    # 2. 性能优化
    # 低效操作检测
    # 发现可能影响性能的代码模式。
    # 示例规则：
    # appendCombine：合并连续的 append 调用
    # rangeExprCopy：避免对大数组进行 range 遍历时的值拷贝

    # 3. 代码可读性
    # 代码简化建议
    # 鼓励更简洁的写法。
    # 示例规则：
    # singleCaseSwitch：将单分支 switch 改为 if
    # elseif：避免深层嵌套的 else if

    # 4. 错误预防
    # 潜在 Bug 检测
    # 发现可能导致逻辑错误的代码模式。
    # 示例规则：
    # badRegexp：检测错误的正则表达式语法
    # dupImport：重复导入同一包
    - gocritic

    # === 安全性检查 ===

    # gosec: 检查常见的安全问题
    # 例如:
    # - 使用 md5 进行密码哈希
    # - SQL 注入风险
    # - 不安全的文件权限
    - gosec

    # === 性能检查 ===

    # prealloc: 建议在合适的场景预分配内存
    # 例如:
    # for i := 0; i < n; i++ {
    #   slice = append(slice, item) // 建议预分配容量
    # }
    - prealloc

    # === 核心代码检查类 ===

    # bidichk: 检查代码中是否存在可能导致显示问题的双向 Unicode 字符
    # 例如: 使用了右至左标记(RTL)的注释可能导致代码显示混乱
    # bad:  // Hello World‮
    # good: // Hello World
    - bidichk

    # canonicalheader: 检查 HTTP 头字段名称是否规范
    # 例如:
    # bad:  req.Header.Set("content-type", "application/json")
    # good: req.Header.Set("Content-Type", "application/json")
    - canonicalheader

    # copyloopvar: 检查 for 循环变量在 goroutine 中的使用是否正确,在go1.22以上已经不需要
    # 例如:
    # bad:
    # for _, v := range items {
    #   go func() {
    #     process(v)  // v 会被多个 goroutine 共享
    #   }()
    # }
    # good:
    # for _, v := range items {
    #   v := v  // 创建新的变量
    #   go func() {
    #     process(v),
    #   }()
    # }
    - copyloopvar

    # depguard: 限制使用特定的依赖包
    # 例如: 禁止使用已废弃的包或不安全的包
    # bad:  import "github.com/golang/protobuf"
    # good: import "google.golang.org/protobuf"
    - depguard

    # durationcheck: 检查时间单位计算是否正确
    # 例如:
    # bad:  time.Duration(1) * time.Second  // 1 被隐式转换
    # good: 1 * time.Second
    - durationcheck

    # errname: 确保错误变量和类型命名符合约定
    # 例如:
    # bad:  var MyError = errors.New("something")
    # good: var ErrSomething = errors.New("something")
    - errname

    # errorlint: 检查错误处理是否符合最新的 Go 错误处理规范
    # 例如:
    # bad:  if err.Error() == "not found" {}
    # good: if errors.Is(err, ErrNotFound) {}
    - errorlint

    # exhaustive: 确保 switch 语句和 map 处理了所有可能的情况
    # 例如:
    # type Color int
    # const (
    #   Red Color = iota
    #   Blue
    #   Green
    # )
    # bad:
    # switch c {
    # case Red: // 没有处理 Blue 和 Green
    # }
    # good:
    # switch c {
    # case Red, Blue, Green:
    # }
    - exhaustive

    # fatcontext: 检测在循环中错误使用上下文的情况
    # 需要共享取消信号时，可选择性禁用
    # 例如:
    #    // bad
    # func fetchAll(ctx context.Context, urls []string) {
    #     for _, url := range urls {
    #         go fetch(ctx, url) // ❌ 所有请求共享同一个 `ctx`
    #     }
    # }
    # // good
    # func fetchAll(ctx context.Context, urls []string) {
    #     for _, url := range urls {
    #         reqCtx, cancel := context.WithTimeout(ctx, 5*time.Second) // ✅ 每个请求独立超时
    #         defer cancel()
    #         go fetch(reqCtx, url)
    #     }
    # }
    - fatcontext

    # forbidigo:  禁止代码中出现特定的标识符（如函数、变量、类型等）。
    # 它可以帮助团队执行 代码规范，防止使用 不推荐 或 危险 的 API。
    # 禁用废弃的函数（如 ioutil.ReadFile，推荐使用 os.ReadFile）
    # 阻止使用不安全的模式（如 panic("TODO") 或 log.Println 在生产代码中）
    # 限制特定包的使用（如禁止直接使用 database/sql，强制使用封装库）
    - forbidigo

    # funlen: 限制函数的长度，保持函数简洁
    # 如果函数超过设定的行数或语句数，建议拆分
    # bad: 超过100行的函数
    # good: 将大函数拆分成多个小函数
    - funlen

    # gochecknoglobals: 检测 Go 代码中的全局变量（global variables），并鼓励开发者避免使用它们。
    # 全局变量可能导致 不可预测的副作用、并发安全问题 和 代码可测试性降低，因此许多团队会限制其使用。
    # 检查所有 var 定义的包级变量。
    # 允许 以下情况：
      # 常量（const）。
      # 错误变量（如 var ErrNotFound = errors.New("not found")）。
      # 测试文件（_test.go）中的全局变量。
    # 如果全局变量是必要的，考虑以下替代方案：
    # 1. 依赖注入（通过函数参数传递，而不是全局状态）。
    # 2. sync.Once 单例模式（确保线程安全）：
    #    var (
    #        dbOnce sync.Once
    #        db     *sql.DB
    #    )
    #    
    #    func GetDB() *sql.DB {
    #        dbOnce.Do(func() {
    #            db = connectDB()
    #        })
    #        return db
    #    }
    # 3. 结构体封装（避免直接暴露全局变量）：
    #    type App struct {
    #        Cache map[string]string
    #    }
    #    
    #    func NewApp() *App {
    #        return &App{Cache: make(map[string]string)}
    #    }
    # - gochecknoglobals

    # gochecknoinits: 检查是否使用了 init 函数
    # init 函数可能导致程序行为难以预测
    # bad:  func init() { ... }
    # good: 使用显式的初始化函数
    - gochecknoinits

    # gocognit: 检查代码的认知复杂度
    # 如果函数逻辑过于复杂，建议重构
    # bad: 嵌套的 if-else 和循环
    # good: 将复杂逻辑拆分成多个简单函数
    - gocognit

    # govet 是一个内置的静态分析工具，用于检查 Go 代码中的常见错误和潜在问题。
    # 它基于 Go 官方工具链中的 go vet，但通过 golangci-lint 的集成提供了更灵活的配置和更高效的批量检查能力。
    # 可疑的代码结构
    # 例如：printf 格式字符串与参数不匹配、错误的 log.Printf 调用。
    # 未使用的变量或标签
    # 检查未被引用的局部变量、冗余的代码标签（如 label:）。
    # 锁复制问题
    # 检测 sync.Mutex 等锁类型的值复制（可能导致并发问题）。
    # 错误的反射用法
    # 如 reflect.Value.Set 使用不当。
    # 其他常见陷阱
    # 比如 time.Format 中错误的布局字符串（必须用 "2006-01-02" 而非其他日期）。
    - govet

    # ineffassign: 检查无效的变量赋值
    # 例如:
    # bad:
    # x := 1
    # x = 2  // x 在这之后没有被使用
    - ineffassign

    # nilnil: 检查函数是否同时返回 nil 错误和 nil 值
    # 例如:
    # bad:  return nil, nil  // 不清楚是成功还是失败
    # good: return nil, ErrNotFound
    - nilnil

    # makezero: 检查切片初始化是否合理
    # 例如:
    # bad:  make([]int, 0, 0)  // 容量为0没有意义
    # good: make([]int, 0, 10) // 预分配合适的容量
    - makezero

    # mirror: 检查 bytes 和 strings 包函数的误用
    # 例如:
    # bad:  bytes.Compare([]byte(s1), []byte(s2))  // 多余的转换
    # good: strings.Compare(s1, s2)
    - mirror

    # mnd: 检测代码中的魔数,魔数是指直接出现在代码中的未解释的数值常量（如 86400 表示一天的秒数），它们会降低代码的可读性和可维护性
    # 例如:
    # bad:  if status == 200 {}
    # good: if status == http.StatusOK {}
    - mnd

    # musttag: 确保结构体标签的正确性
    # 例如:
    # bad:  type User struct { Name string `json:"name,omitEmpty"` }  // 错误的标签
    # good: type User struct { Name string `json:"name,omitempty"` }
    - musttag

    # nakedret: 检查大型函数中的裸返回
    # 例如:
    # bad:
    # func longFunc() (int, error) {
    #   // 50行代码后...
    #   return // 不清楚返回了什么
    # }
    - nakedret

    # nestif: 检查嵌套的 if 语句
    # 建议使用 early return 或拆分函数降低嵌套深度
    # bad:
    # if a {
    #   if b {
    #     if c {
    #       // 过深的嵌套
    #     }
    #   }
    # }
    - nestif

    # noctx: 确保 HTTP 请求使用上下文
    # 例如:
    # bad:  http.Get(url)
    # good: http.NewRequestWithContext(ctx, "GET", url, nil)
    - noctx

    # perfsprint: 建议使用更高效的字符串格式化方式
    # 例如:
    # bad:  fmt.Sprintf("%d", num)
    # good: strconv.Itoa(num)
    - perfsprint

    # revive: 全面的代码规范检查
    # 例如:
    # - 检查包注释
    # - 检查变量命名
    # - 检查空行规范
    - revive

    # sqlclosecheck: 确保 SQL 资源正确关闭
    # 例如:
    # bad:  rows, _ := db.Query("SELECT ...")  // 未调用 rows.Close()
    # good: 
    # rows, _ := db.Query("SELECT ...")
    # defer rows.Close()
    - sqlclosecheck

    # staticcheck: 静态代码分析工具
    # 检查各种常见问题，如:
    # - 死代码
    # - API 使用错误
    # - 性能问题
    - staticcheck

    # testpackage: 确保测试代码在单独的测试包中
    # 例如:
    # bad:  package foo
    # good: package foo_test
    - testpackage

    # unconvert: 检查不必要的类型转换
    # 例如:
    # bad:  int64(i)  // 当 i 已经是 int64 时
    # good: i
    - unconvert

    # unused: 检查未使用的代码
    # 包括:
    # - 未使用的变量
    # - 未使用的函数
    # - 未使用的类型
    - unused

    # wastedassign: 检查无用的变量赋值
    # 例如:
    # bad:
    # x := 1
    # x = 2
    # return x + 1  // x = 1 的赋值是多余的
    - wastedassign

    # whitespace: 检查空白字符使用是否规范
    # 例如:
    # bad:  func foo(){
    # good: func foo() {
    - whitespace

    ## === 可选启用的检查器 ===

    # decorder: 检查声明顺序和数量
    # 建议的顺序是: 类型 -> 常量 -> 变量 -> 函数
    # 例如:
    # bad:
    # var Version = "1.0"
    # type Config struct{}
    # const Timeout = 30
    # 
    # good:
    # type Config struct{}
    # const Timeout = 30
    # var Version = "1.0"
    #- decorder

    # exhaustruct: 检查结构体初始化是否完整
    # 强烈建议启用，可以避免遗漏字段
    # 例如:
    # type User struct {
    #   Name string
    #   Age  int
    # }
    # bad:  u := User{Name: "bob"}  // 遗漏了 Age 字段
    # good: u := User{Name: "bob", Age: 20}
    #- exhaustruct

    # ginkgolinter: Ginkgo/Gomega 测试框架规范检查
    # 如果你使用这些测试框架，建议启用
    # 例如:
    # bad:  Expect(len(list)).To(Equal(0))
    # good: Expect(list).To(BeEmpty())
    #- ginkgolinter

    # godox: 检查 TODO/FIXME 等注释标记
    # 帮助追踪需要处理的技术债务
    # 例如:
    # // TODO: 需要优化这个算法
    # // FIXME: 这里有性能问题
    #- godox

    # goheader: 检查文件头注释是否符合规范
    # 适用于需要统一文件头格式的项目
    # 例如版权声明、作者信息等
    #- goheader

    # inamedparam: 检查接口方法的参数是否命名
    # 好想法但可能过于严格，建议按需启用
    # 例如:
    # bad:  interface { Process(string, int) error }
    # good: interface { Process(name string, age int) error }
    #- inamedparam

    # interfacebloat: 检查接口方法数量
    # 防止接口过于臃肿，建议接口保持精简
    # 例如超过 10 个方法的接口可能需要拆分
    #- interfacebloat

    # ireturn: 建议返回具体类型而不是接口
    # 例如:
    # bad:  func NewReader() io.Reader
    # good: func NewReader() *bytes.Buffer
    #- ireturn

    # tagalign: 检查结构体标签对齐
    # 提高代码可读性
    # 例如:
    # bad:
    # struct {
    #   ID   int    `json:"id"`
    #   Name string `json:"name"`
    # }
    # good:
    # struct {
    #   ID   int    `json:"id"  `
    #   Name string `json:"name"`
    # }
    #- tagalign

    # varnamelen: 检查变量名长度是否与作用域相称
    # 好想法但可能有太多误报
    # 例如: 循环中使用 i 是可以的，但全局变量用单字母可能不合适
    #- varnamelen

    # wrapcheck: 检查是否正确包装外部包的错误
    # 例如:
    # bad:  return err
    # good: return fmt.Errorf("failed to read file: %w", err)
    #- wrapcheck

    ## === 已禁用的检查器（原因说明）===

    # containedctx: 检查结构体中是否包含 context.Context
    # 禁用原因：有些场景确实需要在结构体中存储上下文
    #- containedctx

    # contextcheck: 检查上下文传递
    # 禁用原因：误报太多，特别是在处理中间件时
    #- contextcheck

    # dogsled: 检查多个空白标识符的使用
    # 禁用原因：有时确实需要忽略多个返回值
    # 例如: x, _, _, _ := f()
    #- dogsled

    # dupword: 检查重复单词
    # 禁用原因：需要配置才有用，且容易误报
    # 例如注释中的正常重复词
    #- dupword

    # err113: 错误处理检查
    # 禁用原因：规则过于严格，有些场景不适用
    #- err113

    # gomodguard: 依赖包管理
    # 禁用原因：使用更强大的 depguard 替代
    #- gomodguard

    # nlreturn: 返回语句前的空行要求
    # 禁用原因：过于严格，不总是提高代码可读性
    #- nlreturn

    # wsl: 空白行规范
    # 禁用原因：规则过于严格，有时反而降低可读性
    #- wsl

  # 检查工具的具体配置
  settings:
    cyclop:
      # 圈复杂度是衡量代码复杂性的指标
      # 计算方法：基础值1 + 每个if/for/switch/&&/|| 加1
      # 例如:
      # func example() {          // 基础值 1
      #   if a && b {            // +2 (if和&&)
      #     for i := 0; i < 3 {  // +1 (for)
      #       if x {             // +1 (if)
      #         ...
      #       }
      #     }
      #   }
      # }
      # 总复杂度 = 5
      max-complexity: 30
      package-average: 10.0

    depguard:
      # 依赖包规则配置
      # 可以设置允许和禁止使用的包
      rules:
        # 安全性规则示例
        "security":
          deny:
            # 禁止使用不安全的加密包
            - pkg: "crypto/md5"
              desc: "MD5 不安全，请使用 crypto/sha256"
            - pkg: "crypto/sha1"
              desc: "SHA1 不安全，请使用 crypto/sha256"
        
        # 已废弃包规则
        "deprecated":
          deny:
            - pkg: github.com/golang/protobuf
              desc: 请使用 google.golang.org/protobuf
            - pkg: github.com/satori/go.uuid
              desc: 请使用 github.com/google/uuid

    errcheck:
      # 检查类型断言的错误处理
      # 例如:
      # bad:  value := response.(string)
      # good: value, ok := response.(string)
      check-type-assertions: true

      # 检查空标识符赋值
      # 例如:
      # bad:  _ = reader.Close()
      # good: if err := reader.Close(); err != nil { ... }
      check-blank: true

    exhaustive:
      # 检查 switch 语句是否处理了所有可能的情况
      # 例如对于枚举类型:
      # type Status int
      # const (
      #   StatusPending Status = iota
      #   StatusActive
      #   StatusClosed
      # )
      # 
      # switch status {
      # case StatusPending: // 需要处理所有状态
      # case StatusActive:
      # case StatusClosed:
      # }
      check: [switch, map]

    funlen:
      # 函数长度限制
      # 超过限制的函数建议拆分
      # 例如:
      # bad:
      # func longFunction() {
      #   // 100+ 行代码...
      # }
      # good:
      # func longFunction() {
      #   step1()
      #   step2()
      #   step3()
      # }
      lines: 100
      statements: 50

    govet:
      enable-all: true

      # 禁用字段对齐检查
      # 这个检查会建议你调整结构体字段顺序以节省内存
      # 但这种优化收益通常很小，反而可能降低代码可读性
      # 例如：
      # type User struct {
      #   Name    string // 8字节对齐
      #   Age     int    // 8字节
      #   Active  bool   // 1字节，但会补齐到8字节
      # }
      disable: [fieldalignment]

    mnd:
      # 魔法数字检查的例外配置
      # "魔法数字"是指代码中直接使用的数字常量
      # 一般建议用有意义的常量代替，但有些场景下数字是标准值
      ignored-functions:
        # 文件权限是标准八进制值，不需要定义常量
        # 例如：
        - os.Chmod  # os.Chmod("config.json", 0644) 是标准用法
        
        # Prometheus 的指数桶大小计算也使用标准数值
        # 例如：ExponentialBuckets(100, 2, 5) 表示：[100, 200, 400, 800, 1600]
        - prometheus.ExponentialBuckets.*

    nolintlint:
      # 控制如何使用 nolint 注释来忽略检查警告
      # nolint 注释用于特殊情况下禁用某些检查
      
      # 要求为每个 nolint 注释提供禁用原因
      # 错误：//nolint:errcheck
      # 正确：//nolint:errcheck // 这个错误已经由 defer 处理了
      require-explanation: true

      # 要求明确指定要禁用哪些检查项
      # 错误：//nolint  // 禁用所有检查
      # 正确：//nolint:errcheck,gosec  // 只禁用指定的检查
      require-specific: true
    revive: 
      rules:
        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#package-comments
        - name: package-comments
          severity: warning
          disabled: true
          exclude: [""]

    staticcheck:
      # staticcheck 是一个全面的静态代码分析工具
      # 它能发现各种代码问题，包括：
      # - 无用的代码
      # - API 使用错误
      # - 性能问题等
      checks:
        # 启用所有检查项
        - all
        
        # 忽略包必须有注释的要求
        # 例如：package main 前可以不写注释
        # - ST1000
        
        # 忽略方法接收器的命名一致性要求
        # 例如：允许在不同方法中使用不同的接收器名
        # func (u *User) GetName() {}
        # func (user *User) GetAge() {}
        - ST1016

  exclusions:
    # 是否警告未使用的排除规则
    # 如果设置为 true，当配置文件中的某个排除规则
    # 没有匹配到任何文件时，会收到警告
    warn-unused: true

    rules:
      # 测试文件的特殊规则
      # 测试文件（以 _test.go 结尾）可以违反一些常规规则
      - path: '_test\.go'
        linters:
          # 测试文件可以不关闭 HTTP 响应体
          # 因为测试结束后会自动清理资源
          # 例如：
          # func TestHTTP(t *testing.T) {
          #     resp, _ := http.Get(url)  // 不需要 defer resp.Body.Close()
          # }
          - bodyclose

          # 测试文件可以包含重复代码
          # 因为测试用例经常需要类似的设置代码
          # 例如：多个测试函数都需要创建测试数据
          - dupl
    